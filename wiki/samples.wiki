*一、前言*
 本节分别介绍利用!EasyNetwork搭建单线程和多线程服务器框架的例子。我们的目标是在客户端和服务端传送简单的字符串协议。在搭建服务器框架前，我们需要先创建自己的协议和协议类。这一般也是开发者需要提前准备的。

*二、协议族StringProtocolFamily*
 1. SpringProtocolFamily从DefaultProtocolFamily继承，用于创建和销毁!StringProtocol协议：
{{{

class StringProtocolFamily: public DefaultProtocolFamily
{
public:
	Protocol* create_protocol_by_header(ProtocolHeader *header);
	void destroy_protocol(Protocol *protocol);
 };

inline
Protocol* StringProtocolFamily::create_protocol_by_header(ProtocolHeader *header)
{
	int protocol_type = ((DefaultProtocolHeader *)header)->get_protocol_type();
	Protocol *protocol = NULL;
	switch(protocol_type)
	{
	case PROTOCOL_STRING:
		protocol  =  new StringProtocol;
		break;
	}
	
	return protocol;
}
 
inline
void StringProtocolFamily::destroy_protocol(Protocol *protocol)
{
	delete protocol;
}
}}}
 这两个接口允许开发者自己控制协议的创建和销毁方式，比如开发者可以提供自己的内存管理模块，并从内存管理模块中分配和销毁自己的协议对象。[Download 多任务多线程下载]展示了利用内存管理模块分配协议对象的例子。

<br><br>
2. !StringProtocol协议
 !StringProtocol从Protocol继承，需要实现encode_body和decode_body等接口方法：
{{{
class StringProtocol:public Protocol
{
public: 
	//协议的描述信息 
	const char* details(){return "raw_string_protocol";}
	//编码协议体数据到io_buffer,成功返回true,失败返回false. 	
	bool encode_body(ByteBuffer *byte_buffer); 	
	//解码协议体数据io_buffer.成功返回true,失败返回false. 	
	bool decode_body(const char *buf, int size);
};

/////////////////////////////////////////////////////////////////////
//编码整数
#define ENCODE_INT(i) do{ \
if(!byte_buffer->append((const char*)&i, sizeof(i))) \
	return false; \
}while(0)
//解码整数
#define DECODE_INT(i) do{ \
if(size < sizeof(i)) return false; \
	i = *(int*)buf; buf+=sizeof(i); size-=sizeof(i); \
}while(0)
 
//编码字符串
#define ENCODE_STRING(str) do{\
len = str.size(); \
if(!byte_buffer->append((const char*)&len, sizeof(len))) \
	return false; \
if(len > 0 && !byte_buffer->append(str.c_str())) \
	return false; \
 }while(0)
//解码字符串
#define DECODE_STRING(str) do{\
DECODE_INT(len); \
if(len<0 || size<len) return false; \
if(len > 0) \
	str.assign(buf, len); buf+=len; size-=len; \
}while(0)
 
//编码协议体数据到io_buffer,成功返回true,失败返回false.
inline
bool StringProtocol::encode_body(ByteBuffer *byte_buffer)
{
	int len = 0;
	////m_str
	ENCODE_STRING(m_str);

	return true;
}
//解码协议体数据io_buffer.成功返回true,失败返回false.
inline
bool StringProtocol::decode_body(const char *buf, int size)
{
	int len = 0;
	////m_str
	DECODE_STRING(m_str);

	return true;
}
}}}


<br><br>
*三、单线程开发范式*
 单线程开发范式指服务器只有一个线程，在这个线程里面监听服务端口、接收链接请求、处理客户端发送的请求等。该例子见框架源码中的AppFramework_Sample。

 1. 利用enetlib工具生产框架代码
{{{
enetlib -s ServerAppFramework -main
enetlib -s ClientAppFramework -main
}}}
 将在当前目录中生成如下6个文件，分别时客户端和服务端的代码框架：
{{{
ClientAppFramework.cpp
ClientAppFramework.h
ClientAppFrameworkMain.cpp

ServerAppFramework.cpp
ServerAppFramework.h
ServerAppFrameworkMain.cpp
}}}

2. 添加服务端框架代码
{{{
//ServerAppFramework.cpp
//实现NetInterface的接口
bool ServerAppFramework::start_server()
{
	////Init NetInterface
	init_net_interface();

	////Add Your Codes From Here
	ListenSocket linsten_socket(3010);
	if(!linsten_socket.open())
	{
		SLOG_ERROR("listen on port:3010 error.");
		return -1;
	}

	//listen event
	ListenHandler listen_handler(this);
	get_io_demuxer()->register_event(linsten_socket.get_handle(), EVENT_READ|EVENT_PERSIST, -1, &listen_handler);
	//timer event
	TimerHandler timer(get_io_demuxer());
	get_io_demuxer()->register_event(-1, EVENT_INVALID, 3000, &timer);

	//run server forever
	get_io_demuxer()->run_loop();

	return true;
}
//创建销毁协议族
ProtocolFamily* ServerAppFramework::create_protocol_family()
{
	return new StringProtocolFamily;
}
void ServerAppFramework::delete_protocol_family(ProtocolFamily* protocol_family)
{
	delete protocol_family;
}

//接收客户端请求
bool ServerAppFramework::on_recv_protocol(SocketHandle socket_handle, Protocol *protocol, bool &detach_protocol)
{
	DefaultProtocolHeader *header = (DefaultProtocolHeader*)protocol->get_protocol_header();
	DefaultProtocolFamily* protocol_family = (DefaultProtocolFamily *)get_protocol_family();
	switch(header->get_protocol_type())
	{
	case PROTOCOL_STRING:
		{
			StringProtocol* string_protocol = (StringProtocol*)protocol;
			SLOG_INFO("receive string protocol from fd=%d. receive data:[%s].", socket_handle, string_protocol->get_string().c_str());

			StringProtocol *resp_protocol = (StringProtocol *)protocol_family->create_protocol(PROTOCOL_STRING);
			string str = "server respond";
			resp_protocol->set_string(str);
			//发送协议
			if(!send_protocol(socket_handle, resp_protocol))
			{
				SLOG_ERROR("send protocol failed.");
				protocol_family->destroy_protocol(resp_protocol);
			}
		}
		break;
	default:
		SLOG_ERROR("receive undefine protocol. ignore it.");
		return false;
	}

	return true;
}
}}}
 这里只简单介绍几个主要的接口方法。其他详细内容见源码。

<br><br>
3. 添加客户端框架代码
{{{
//ClientAppFramework.cpp
//实现NetInterface的接口
bool ClientAppFramework::start_server()
{
	////Init NetInterface
	init_net_interface();

	////Add Your Codes From Here
	SocketHandle socket_handle = get_active_trans_socket("127.0.0.1", 3010);  //创建主动连接
	if(socket_handle == SOCKET_INVALID)
		return false;

	PingHandler ping_handler(this, socket_handle);
	ping_handler.register_handler();

	get_io_demuxer()->run_loop();

	return true;
}
//创建销毁协议族
ProtocolFamily* ClientAppFramework::create_protocol_family()
{
	return new StringProtocolFamily;
}
void ClientAppFramework::delete_protocol_family(ProtocolFamily* protocol_family)
{
	delete protocol_family;
}

//接收服务端响应
bool ClientAppFramework::on_recv_protocol(SocketHandle socket_handle, Protocol *protocol, bool &detach_protocol)
{
	DefaultProtocolHeader *header = (DefaultProtocolHeader*)protocol->get_protocol_header();
	int type = header->get_protocol_type();
	switch(type)
	{
	case PROTOCOL_STRING:
		{
			StringProtocol *str_protocol = (StringProtocol *)protocol;
			SLOG_INFO("client recv resp:[%s].", str_protocol->get_string().c_str());
		}
		break;
	default:
		SLOG_ERROR("receive undefine protocol. ignore it.");
		return false;
	}

	//get_io_demuxer()->exit();
	return true;
}
}}}

<br><br>
4. 编译运行
{{{
make
./test_server
./test_client
}}}


<br><br>
*四、多线程开发范式*
 多线程开发范式指服务器使用一个主线程监听服务端口，当接收到链接请求时，把该新链接按某种策略分配到其他子线程，由该子线程负责对新链接的监听、处理客户端发送的请求等。当新链接分配到某个子线程后，该链接和主线程不再有任何关系。


<br><br>