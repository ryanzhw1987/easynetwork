<h1>前言</h1>
  本节介绍一个使用EasyNetwork框架搭建的多任务/多线程下载服务器。该Donwload server/client比较简单,没有做过多的优化和检查工作来保证服务的稳定性。因为我们的focus是“怎么使用框架搭建Download server"，而不是“Download server"。当然，现在我们只要把精力放在应用层的实现逻辑就可以了。
 
  整个服务器/客户端的工作流程大概如下：客户端向服务端发送请求文件大小的协议，收到服务端回复之后根据文件大小进行分片；客户端向服务端请求每个分片的数据；服务端收到请求分片的任务后，按照分片在文件中的起始位置和大小读取数据并发送给客户端。
 
  另外，在协议族中创建和销毁协议对象时我们使用来MemCache内存管理模块来控制内存的分配和释放，从而避免产生内存碎片。具体间下面的协议族定义。
 
  好吧，进入主题，本次新闻联播的主要内容有：
   * [MThreadDownload#1._Download_ProtocolFamily]
   * [MThreadDownload#2._Download_Server]
   * [MThreadDownload#3._Download_Client]
   * [MThreadDownload#4._Ending]
 
 
==1. Download ProtocolFamily==
  搭建框架之前我们先定义好协议和协议族。我们利用框架的DefaultProtocol来定义我们下载服务器需要用到的4个协议:RequestSize, RespondSize, RequestData, RespondData.(具体见源码)
 
  a) RequestSize请求文件大小
 {{{
 //DownloadProtocolFamily.h
 //请求文件大小
 class RequestSize: public Protocol
 {
 public://实现protocol的接口
 	//协议的描述信息
 	const char* details(){return "RequestSize";}
 	//编码协议体数据到byte_buffer,成功返回true,失败返回false.
 	bool encode_body(ByteBuffer *byte_buffer);
 	//解码大小为size的协议体数据buf.成功返回true,失败返回false.
 	bool decode_body(const char *buf, int size);
 public:
 	RequestSize(){}
 	RequestSize(string &filename)
 	{
 		m_file_name = filename;
 	}
 	void assign(const string &file_name){m_file_name = file_name;}
 	const string& get_file_name(){return m_file_name;}
 private:
 	string m_file_name;
 };
 
 //DownloadProtocolFamily.cpp
 //编码协议体数据到byte_buffer,成功返回true,失败返回false.
 bool RequestSize::encode_body(ByteBuffer *byte_buffer)
 {
 	int len = 0;
 	//file name
 	ENCODE_STRING(m_file_name);
 
 	return true;
 }
 
 //解码大小为size的协议体数据buf.成功返回true,失败返回false.
 bool RequestSize::decode_body(const char* buf, int size)
 {
 	int len = 0;
 	//file name
 	DECODE_STRING(m_file_name);
 
 	return true;
 }
 }}}
  在编解码中我们使用来ENCODE_STRING和DECODE_STRING两个宏定义以便快速的编解码相关字段。这些宏定义在库Protocol.h。
 
  b) RespondSize 回复文件大小（略）
 
  c) RequestData 请求文件数据（略）
 
  d) RespondData 回复文件数据（略）
 
  e) DownloadProtocolFamily下载协议族
  最后需要定义一个协议族类用来创建和销毁协议：
 {{{
 //DownloadProtocolFamily.h
 class DownloadProtocolFamily:public DefaultProtocolFamily
 {
 public:
 	Protocol* create_protocol_by_header(ProtocolHeader *header);
 	void destroy_protocol(Protocol *protocol);
 private:
 	//memory cache:
 	MemCache<RequestSize> m_request_size_memcache;
 	MemCache<RespondSize> m_respond_size_memcache;
 	MemCache<RequestData> m_request_data_memcache;
 	MemCache<RespondData> m_respond_data_memcache;
 };
 
 //DownloadProtocolFamily.cpp
 /////////////////////////////////////////////////////////////////////////////////
 Protocol* DownloadProtocolFamily::create_protocol_by_header(ProtocolHeader *header)
 {
 	int protocol_type = ((DefaultProtocolHeader *)header)->get_protocol_type();
 	Protocol *protocol = NULL;
 	switch(protocol_type)
 	{
 	case PROTOCOL_REQUEST_SIZE:
 		protocol = (Protocol*)m_request_size_memcache.Alloc();
 		SLOG_DEBUG("create RequestSize[%x] from m_request_size_memcache", protocol);
 		break;
 	case PROTOCOL_RESPOND_SIZE:
 		protocol = (Protocol*)m_respond_size_memcache.Alloc();
 		SLOG_DEBUG("create RespondSize[%x] from m_respond_size_memcache", protocol);
 		break;
 	case PROTOCOL_REQUEST_DATA:
 		protocol = (Protocol*)m_request_data_memcache.Alloc();
 		SLOG_DEBUG("create RequestData[%x] from m_request_data_memcache", protocol);
 		break;
 	case PROTOCOL_RESPOND_DATA:
 		protocol = (Protocol*)m_respond_data_memcache.Alloc();
 		SLOG_DEBUG("create RespondData[%x] from m_respond_data_memcache", protocol);
 		break;
 	default:
 		break;
 	}
 
 	return protocol;
 }
 
 void DownloadProtocolFamily::destroy_protocol(Protocol* protocol)
 {
 	if(protocol == NULL)
 		return;
 	DefaultProtocolHeader *header = (DefaultProtocolHeader *)protocol->get_protocol_header();
 	switch(header->get_protocol_type())
 	{
 	case PROTOCOL_REQUEST_SIZE:
 	{
 		SLOG_DEBUG("free DownloadRequest[%x] to m_request_size_memcache", protocol);
 		RequestSize *temp_protocol = (RequestSize*)protocol;
 		m_request_size_memcache.Free(temp_protocol);
 		break;
 	}
 	case PROTOCOL_RESPOND_SIZE:
 	{
 		SLOG_DEBUG("free RespondSize[%x] to m_respond_size_memcache", protocol);
 		RespondSize *temp_protocol = (RespondSize*)protocol;
 		m_respond_size_memcache.Free(temp_protocol);
 		break;
 	}
 	case PROTOCOL_REQUEST_DATA:
 	{
 		SLOG_DEBUG("free RequestData[%x] to m_request_data_memcache", protocol);
 		RequestData *temp_protocol = (RequestData*)protocol;
 		m_request_data_memcache.Free(temp_protocol);
 		break;
 	}
 	case PROTOCOL_RESPOND_DATA:
 	{
 		SLOG_DEBUG("free RespondData[%x] to m_respond_data_memcache", protocol);
 		RespondData *temp_protocol = (RespondData*)protocol;
 		m_respond_data_memcache.Free(temp_protocol);
 		break;
 	}
 	default:
 		break;
 	}
 }
 }}}
  协议族需要实现create_protocol_by_header和destroy_protocol两个接口方法，用来创建/销毁具体的协议。
 
  另外代码中使用了MemCache模块来控制内存空间到分配。协议的创建和销毁在实际项目中是非常频繁的操作，通过使用内存管理模块可以避免产生内存碎片而导致程序效率降低的问题。
 
==2. Download Server==
 这一节开始我们介绍多任务/多线程下载服务。服务器的框架大体如下：
  * 服务器收到一个新链接时，将该链接分配到某个线程，由该线程处理在该链接上的请求。
  * 某个线程收到RequestSize协议时，返回指定的file_name文件的大小给客户端(回复RespondSize协议)。
  * 某个线程收到RequestData协议请求时，按协议指定的数据偏移位置start_pos和分片大小将分片数据返回给客户端(回复RespondData协议)。

 (1) 利用enetlib工具生成框架代码类
{{{
enetlib -m DownloadServer -main
}}}
 生成了3个文件：
{{{
DownloadServer.cpp 
DownloadServer.h
DownloadServerMain.cpp 
}}}
 ok, 我们的下载服务器完成了, 收工....开玩笑的, 还需要添加业务逻辑层代码呢:

 (2) DownloadServer 线程

 DownloadServer从!ConnectThread继承，实际是一个!NetInterface的实例，因此需要实现!NetInterface的接口方法。
{{{
////创建/消毁协议族
ProtocolFamily* DownloadServer::create_protocol_family()
{ 
	return new DownloadProtocolFamily;
}
void DownloadServer::delete_protocol_family(ProtocolFamily* protocol_family)
{
	delete protocol_family;
} 
}}}
 
 接下来当然是处理请求协议,来看看我们是如何做到的:当然是实现on_recv_protocol接口了.
{{{
bool DownloadServer::on_recv_protocol(SocketHandle socket_handle, Protocol *protocol, bool &detach_protocol)
{
	DownloadProtocolFamily* protocol_family = (DownloadProtocolFamily*)get_protocol_family();
	DefaultProtocolHeader *header = (DefaultProtocolHeader *)protocol->get_protocol_header();
	switch(header->get_protocol_type())
	{
	case PROTOCOL_REQUEST_SIZE:
	{
		RequestSize *temp_protocol = (RequestSize*)protocol;
		const string file_name = temp_protocol->get_file_name();
		SLOG_INFO("receive <RequestSize:file=%s>", file_name.c_str());

		string path="/data/";
		path += file_name;

		//get file size
		unsigned long long file_size=0;
		FILE *fp = fopen(path.c_str(), "r");
		if(fp != NULL)
		{
			fseek(fp, 0, SEEK_END);
			file_size = ftell(fp);
			fseek(fp, 0, SEEK_SET);
			fclose(fp);
		}

		RespondSize* resp_protocol = (RespondSize*)protocol_family->create_protocol(PROTOCOL_RESPOND_SIZE);
		if(resp_protocol)
		{
			resp_protocol->assign(file_name, file_size);
			send_protocol(socket_handle, resp_protocol);
		}
		else
			SLOG_ERROR("create RespondSize protocol failed.");

		break;
	}
	case PROTOCOL_REQUEST_DATA:
	{
		RequestData *temp_protocol = (RequestData*)protocol;
		const string file_name = temp_protocol->get_file_name();
		unsigned long long start_pos = temp_protocol->get_start_pos();
		unsigned int size = temp_protocol->get_size();
		SLOG_INFO("receive <RequestData: file=%s, start_pos=%ld, size=%d>", file_name.c_str(), start_pos, size);

		string path="/data/";
		path += file_name;
		FILE *fp = fopen(path.c_str(), "r");
		if(fp != NULL)
		{
			RespondData* resp_protocol = (RespondData*)protocol_family->create_protocol(PROTOCOL_RESPOND_DATA);
			resp_protocol->assign(file_name, start_pos, size);

			DefaultProtocolHeader *header = (DefaultProtocolHeader *)resp_protocol->get_protocol_header();
			int header_length = header->get_header_length();
			ByteBuffer *byte_buffer = new ByteBuffer;
			//1. 预留协议头空间
			byte_buffer->get_append_buffer(header_length);
			byte_buffer->set_append_size(header_length);
			//2. 编码协议体数据
			resp_protocol->encode_body(byte_buffer);
			//3. 添加数据
			char *data_buffer = byte_buffer->get_append_buffer(size);
			fseek(fp, start_pos, SEEK_SET);
			fread(data_buffer, 1, size, fp);
			fclose(fp);
			byte_buffer->set_append_size(size);
			//4. 编码协议头
			int body_length = byte_buffer->size()-header_length;
			char *header_buffer = byte_buffer->get_data(0, header_length);
			header->encode(header_buffer, body_length);
			//5. 发送协议
			resp_protocol->attach_raw_data(byte_buffer);
			send_protocol(socket_handle, resp_protocol);
		}
		else
		{
			SLOG_ERROR("can't open file=%s", file_name.c_str());
		}
		break;
	}
	default:
		SLOG_WARN("receive undefine protocol. ignore it.");
		return false;
	}
 
	return true;
}
}}}
 

==3. Download Client==

==4. Ending==