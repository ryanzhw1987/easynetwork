#summary One-sentence summary of this page.

= Introduction =

本节介绍一个使用EasyNetwork框架搭建到下载服务器.该服务器支持多任务/多线程/下载,支持断点续传.

该Donwload server/client比较简单,没有过多的优化工作,以及保证服务的稳定性以及.因为我们的focus是“怎么使用框架搭建Download server",而不是“Download server". 当然,现在我们的精力是在应用层,而不是框架.呵呵...好吧,进入主题,本次新闻联播的主要内容有:
 * [Download#1_Download_Protocol]
 * [Download#2_Download_Server]
 * [Download#3_Download_Client]


= 1 Download Protocol =
下载协议,是最基本到要求了,我就不说啥了. 我们利用框架的DefaultProtocol来定义我们下载的4个协议:RequestSize, RespondSize, RequestData, RespondData.

 * *RequestSize 请求文件大小*
{{{
class RequestSize: public DefaultProtocol
{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RequestSize():DefaultProtocol(PROTOCOL_REQUEST_SIZE){}
	RequestSize(string &filename):DefaultProtocol(PROTOCOL_REQUEST_SIZE)
	{
		m_file_name = filename;
	}
	void assign(const string &file_name){m_file_name = file_name;}
	const string& get_file_name(){return m_file_name;}
private:
	string m_file_name;
};
}}}

 * *RespondSize 回复文件大小*
{{{
class RespondSize: public DefaultProtocol
{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RespondSize():DefaultProtocol(PROTOCOL_RESPOND_SIZE), m_file_size(0){}
	RespondSize(string &filename, unsigned long long file_size):DefaultProtocol(PROTOCOL_RESPOND_SIZE)
	{
		m_file_size = file_size;
		m_file_name = filename;
	}

	void assign(const string &file_name, unsigned long long file_size)
	{
		m_file_name = file_name;
		m_file_size = file_size;
	}

	const string& get_file_name(){return m_file_name;}
	unsigned long long get_file_size(){return m_file_size;}
private:
	unsigned long long m_file_size;
	string m_file_name;
};
}}}

 * *RequestData 请求文件数据*
{{{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RequestData():DefaultProtocol(PROTOCOL_REQUEST_DATA), m_start_pos(0), m_size(0){}
	RequestData(string &filename, unsigned long long start_pos, unsigned int size):DefaultProtocol(PROTOCOL_REQUEST_DATA)
	{
		m_start_pos = start_pos;
		m_size = size;
		m_file_name = filename;
	}

	void assign(const string &file_name, unsigned long long start_pos, unsigned int size)
	{
		m_file_name = file_name;
		m_start_pos = start_pos;
		m_size = size;
	}

	unsigned long long get_start_pos(){return m_start_pos;}
	unsigned int get_size(){return m_size;}
	const string& get_file_name(){return m_file_name;}
private:
	unsigned long long m_start_pos;
	unsigned int m_size;
	string m_file_name;
};
}}}

 * *RespondData 回复文件数据*
{{{
class RespondData: public DefaultProtocol
{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RespondData():DefaultProtocol(PROTOCOL_RESPOND_DATA), m_start_pos(0), m_size(0){}
	RespondData(string &filename, unsigned long long start_pos, unsigned int size, string &data):DefaultProtocol(PROTOCOL_RESPOND_DATA)
	{
		m_start_pos = start_pos;
		m_size = size;
		m_file_name = filename;
		m_data = data;
	}

	void assign(const string &file_name, unsigned long long start_pos, unsigned int size)
	{
		m_file_name = file_name;
		m_start_pos = start_pos;
		m_size = size;
	}

	void assign(string &data)
	{
		m_data = data;
	}

	const string& get_file_name(){return m_file_name;}
	const string& get_data(){return m_data;}
	unsigned long long get_start_pos(){return m_start_pos;}
	unsigned int get_size(){return m_size;}

private:
	string m_file_name;
	string m_data;
	unsigned long long m_start_pos;
	unsigned int m_size;
};
}}}


 * *DownloadProtocolFamily协议族*
最后需要定义一个协议族来生成上面四个协议
{{{
class DownloadProtocolFamily:public DefaultProtocolFamily
{
public:
	Protocol* create_protocol(ProtocolType protocol_type, bool new_header=true);
	int destroy_protocol(Protocol* protocol);
private:
	//memory cache: StringProtocol
	MemCache<RequestSize> m_request_size_memcache;
	MemCache<RespondSize> m_respond_size_memcache;
	MemCache<RequestData> m_request_data_memcache;
	MemCache<RespondData> m_respond_data_memcache;
};
}}}


= 2 Download Server =
这一节我们介绍一个多线程下载服务器.
1.服务器收到一个请求时,将该任务分配到某个线程,由该线程处理对应的请求.
2.某个线程收到RequestSize时,返回协议指定file_name返回文件的大小给客户端(回复RespondSize协议).
3.某个线程收到RequestData请求时,按协议指定的数据偏移start_pos请求file_name的size大小的数据块返回给客户端(回复RespondData协议).

 * *Download 线程池*
下载线程池从框架到ConnectThreadPool继承,创建下载线程:
{{{
class DownloadThreadPool:public ConnectThreadPool
{
public:
	DownloadThreadPool(unsigned int thread_num):ConnectThreadPool(thread_num){}
protected:
	//实现创建一个线程
	Thread<SocketHandle>* create_thread();
};

//创建下载线程
Thread<SocketHandle>* DownloadThreadPool::create_thread()
{
	...
	DownloadServer* temp = new DownloadServer(io_demuxer, protocol_family, socket_manager);
	...
	return (Thread<SocketHandle>*)temp;
}

}}}

 * *Download 线程*
下载线程从ConnectThread继承,实现基类的接口,提供请求文件大小和下载数据的功能
{{{
class DownloadServer:public ConnectThread
{
public:
	DownloadServer(IODemuxer *io_demuxer, ProtocolFamily *protocol_family, SocketManager* socket_manager)
			:ConnectThread(io_demuxer, protocol_family, socket_manager)
	{}

	//////////////////由应用层重写 接收协议函数//////////////////
	int on_recv_protocol(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 协议发送错误处理函数//////////
	int on_protocol_send_error(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 协议发送成功处理函数//////////
	int on_protocol_send_succ(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 连接错误处理函数//////////////
	int on_socket_handle_error(SocketHandle socket_handle);
	//////////////////由应用层重写 连接超时处理函数//////////////
	int on_socket_handle_timeout(SocketHandle socket_handle);

protected://实现Thread到纯虚函数
	void run();
};
}}}

 * run
实现线程接口run比较简单,调用IODemuxer的run_loop(),望穿秋水的,默默的等待请求的到来.
{{{
void DownloadServer::run()
{
	SLOG_INFO("MTServerAppFramework[ID=%d] is running...", get_id());
	get_io_demuxer()->run_loop();
	SLOG_INFO("MTServerAppFramework end...");
}
}}}

 * 接收请求协议
处理请求协议是核心了,来看看我们是如何做到的:当然是实现on_recv_protocol接口了.

{{{
int DownloadServer::on_recv_protocol(SocketHandle socket_handle, Protocol *protocol)
{
	switch(((DefaultProtocol*)protocol)->get_type())
	{
	case PROTOCOL_REQUEST_SIZE: //请求文件大小
	{
		RequestSize *temp_protocol = (RequestSize*)protocol;
		const string file_name = temp_protocol->get_file_name();
		SLOG_INFO("receive <RequestSize:file=%s>", file_name.c_str());

		//大家一定要原谅我下面偷懒的行为
		string path="/data/"; 
		path += file_name;

		//get file size
		unsigned long long file_size=0;
		FILE *fp = fopen(path.c_str(), "r");
		if(fp != NULL)
		{
			fseek(fp, 0, SEEK_END);
			file_size = ftell(fp);
			fseek(fp, 0, SEEK_SET);
			fclose(fp);
		}
		DownloadProtocolFamily* protocol_family = (DownloadProtocolFamily*)get_protocol_family();
		RespondSize* resp_protocol = (RespondSize*)protocol_family->create_protocol(PROTOCOL_RESPOND_SIZE);
		if(resp_protocol)
		{
			resp_protocol->assign(file_name, file_size);
			send_protocol(socket_handle, resp_protocol);//发送回复
		}
		else
			SLOG_ERROR("create RespondSize protocol failed.");

		break;
	}
	case PROTOCOL_REQUEST_DATA: //请求数据
	{
		RequestData *temp_protocol = (RequestData*)protocol;
		const string file_name = temp_protocol->get_file_name();
		unsigned long long start_pos = temp_protocol->get_start_pos();
		unsigned int size = temp_protocol->get_size();
		SLOG_INFO("receive <RequestData: file=%s, start_pos=%ld, size=%d>", file_name.c_str(), start_pos, size);

		//大家一定要原谅我下面偷懒的行为
		string path="/data/";
		path += file_name;
		FILE *fp = fopen(path.c_str(), "r");
		if(fp != NULL)
		{
			IOBuffer io_buffer;
			fseek(fp, start_pos, SEEK_SET);
			char* buf = io_buffer.write_open(size);
			fread(buf, 1, size, fp);
			fclose(fp);
			string data;
			data.assign(buf, size);  //获取数据
			io_buffer.write_close(size);

			DownloadProtocolFamily* protocol_family = (DownloadProtocolFamily*)get_protocol_family();
			RespondData* resp_protocol = (RespondData*)protocol_family->create_protocol(PROTOCOL_RESPOND_DATA);
			if(resp_protocol)
			{
				resp_protocol->assign(file_name, start_pos, size);
				resp_protocol->assign(data);
				send_protocol(socket_handle, resp_protocol); //发送回复
			}
		}
		else
		{
			SLOG_ERROR("can't open file=%s", file_name.c_str());
		}
		break;
	}
	default:
		SLOG_WARN("receive undefine protocol. ignore it.");
		break;
	}

	return 0;
}
}}}


嗯,我们到下载服务器完成了.收工,洗洗睡了...
哦,忘记还有客户端的代码,顺便提供一下,嘿嘿...


= 3 Download Client =