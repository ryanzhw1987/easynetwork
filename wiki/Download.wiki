#summary One-sentence summary of this page.

= Introduction =

本节介绍一个使用EasyNetwork框架搭建的下载服务器.该服务器支持多任务/多线程/下载,支持断点续传.

该Donwload server/client比较简单,没有做过多的优化/检查工作来保证服务的稳定性.因为我们的focus是“怎么使用框架搭建Download server",而不是“Download server". 当然,现在我们只要把精力放在应用层的实现逻辑就可以了,呵呵...好吧,进入主题,本次新闻联播的主要内容有:
 * [Download#1_Download_Protocol]
 * [Download#2_Download_Server]
 * [Download#3_Download_Client]


= 1 Download Protocol =
下载协议,是最基本到要求了,我就不说啥了. 我们利用框架的DefaultProtocol来定义我们下载的4个协议:RequestSize, RespondSize, RequestData, RespondData.

 * *RequestSize 请求文件大小*
{{{
class RequestSize: public DefaultProtocol
{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RequestSize():DefaultProtocol(PROTOCOL_REQUEST_SIZE){}
	RequestSize(string &filename):DefaultProtocol(PROTOCOL_REQUEST_SIZE)
	{
		m_file_name = filename;
	}
	void assign(const string &file_name){m_file_name = file_name;}
	const string& get_file_name(){return m_file_name;}
private:
	string m_file_name;
};
}}}

 * *RespondSize 回复文件大小*
{{{
class RespondSize: public DefaultProtocol
{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RespondSize():DefaultProtocol(PROTOCOL_RESPOND_SIZE), m_file_size(0){}
	RespondSize(string &filename, unsigned long long file_size):DefaultProtocol(PROTOCOL_RESPOND_SIZE)
	{
		m_file_size = file_size;
		m_file_name = filename;
	}

	void assign(const string &file_name, unsigned long long file_size)
	{
		m_file_name = file_name;
		m_file_size = file_size;
	}

	const string& get_file_name(){return m_file_name;}
	unsigned long long get_file_size(){return m_file_size;}
private:
	unsigned long long m_file_size;
	string m_file_name;
};
}}}

 * *RequestData 请求文件数据*
{{{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RequestData():DefaultProtocol(PROTOCOL_REQUEST_DATA), m_start_pos(0), m_size(0){}
	RequestData(string &filename, unsigned long long start_pos, unsigned int size):DefaultProtocol(PROTOCOL_REQUEST_DATA)
	{
		m_start_pos = start_pos;
		m_size = size;
		m_file_name = filename;
	}

	void assign(const string &file_name, unsigned long long start_pos, unsigned int size)
	{
		m_file_name = file_name;
		m_start_pos = start_pos;
		m_size = size;
	}

	unsigned long long get_start_pos(){return m_start_pos;}
	unsigned int get_size(){return m_size;}
	const string& get_file_name(){return m_file_name;}
private:
	unsigned long long m_start_pos;
	unsigned int m_size;
	string m_file_name;
};
}}}

 * *RespondData 回复文件数据*
{{{
class RespondData: public DefaultProtocol
{
public://实现protocol的接口
	//编码协议体数据到io_buffer.成功返回编码后协议体长度(大于0),失败返回-1;
	int encode_body(IOBuffer *io_buffer);
	//解码包体.成功返回0,否则返回-1;
	int decode_body(const char* buf, int buf_size);
public:
	RespondData():DefaultProtocol(PROTOCOL_RESPOND_DATA), m_start_pos(0), m_size(0){}
	RespondData(string &filename, unsigned long long start_pos, unsigned int size, string &data):DefaultProtocol(PROTOCOL_RESPOND_DATA)
	{
		m_start_pos = start_pos;
		m_size = size;
		m_file_name = filename;
		m_data = data;
	}

	void assign(const string &file_name, unsigned long long start_pos, unsigned int size)
	{
		m_file_name = file_name;
		m_start_pos = start_pos;
		m_size = size;
	}

	void assign(string &data)
	{
		m_data = data;
	}

	const string& get_file_name(){return m_file_name;}
	const string& get_data(){return m_data;}
	unsigned long long get_start_pos(){return m_start_pos;}
	unsigned int get_size(){return m_size;}

private:
	string m_file_name;
	string m_data;
	unsigned long long m_start_pos;
	unsigned int m_size;
};
}}}


 * *DownloadProtocolFamily协议族*
最后需要定义一个协议族来生成上面四个协议
{{{
class DownloadProtocolFamily:public DefaultProtocolFamily
{
public:
	Protocol* create_protocol(ProtocolType protocol_type, bool new_header=true);
	int destroy_protocol(Protocol* protocol);
private:
	//memory cache: StringProtocol
	MemCache<RequestSize> m_request_size_memcache;
	MemCache<RespondSize> m_respond_size_memcache;
	MemCache<RequestData> m_request_data_memcache;
	MemCache<RespondData> m_respond_data_memcache;
};
}}}


= 2 Download Server =
这一节我们介绍一个多线程下载服务器.
1.服务器收到一个请求时,将该任务分配到某个线程,由该线程处理对应的请求.
2.某个线程收到RequestSize时,返回协议指定file_name返回文件的大小给客户端(回复RespondSize协议).
3.某个线程收到RequestData请求时,按协议指定的数据偏移start_pos请求file_name的size大小的数据块返回给客户端(回复RespondData协议).

 * *Download 线程池*
下载线程池从框架到ConnectThreadPool继承,创建下载线程:
{{{
class DownloadThreadPool:public ConnectThreadPool
{
public:
	DownloadThreadPool(unsigned int thread_num):ConnectThreadPool(thread_num){}
protected:
	//实现创建一个线程
	Thread<SocketHandle>* create_thread();
};

//创建下载线程
Thread<SocketHandle>* DownloadThreadPool::create_thread()
{
	...
	DownloadServer* temp = new DownloadServer(io_demuxer, protocol_family, socket_manager);
	...
	return (Thread<SocketHandle>*)temp;
}

}}}

 * *Download 线程*
下载线程从ConnectThread继承,实现基类的接口,提供请求文件大小和下载数据的功能
{{{
class DownloadServer:public ConnectThread
{
public:
	DownloadServer(IODemuxer *io_demuxer, ProtocolFamily *protocol_family, SocketManager* socket_manager)
			:ConnectThread(io_demuxer, protocol_family, socket_manager)
	{}

	//////////////////由应用层重写 接收协议函数//////////////////
	int on_recv_protocol(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 协议发送错误处理函数//////////
	int on_protocol_send_error(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 协议发送成功处理函数//////////
	int on_protocol_send_succ(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 连接错误处理函数//////////////
	int on_socket_handle_error(SocketHandle socket_handle);
	//////////////////由应用层重写 连接超时处理函数//////////////
	int on_socket_handle_timeout(SocketHandle socket_handle);

protected://实现Thread到纯虚函数
	void run();
};
}}}

 * run
实现线程接口run比较简单,调用IODemuxer的run_loop(),望穿秋水的,默默的等待请求的到来.
{{{
void DownloadServer::run()
{
	SLOG_INFO("MTServerAppFramework[ID=%d] is running...", get_id());
	get_io_demuxer()->run_loop();
	SLOG_INFO("MTServerAppFramework end...");
}
}}}

 * 接收请求协议
处理请求协议是核心了,来看看我们是如何做到的:当然是实现on_recv_protocol接口了.

{{{
int DownloadServer::on_recv_protocol(SocketHandle socket_handle, Protocol *protocol)
{
	switch(((DefaultProtocol*)protocol)->get_type())
	{
	case PROTOCOL_REQUEST_SIZE: //请求文件大小
	{
		RequestSize *temp_protocol = (RequestSize*)protocol;
		const string file_name = temp_protocol->get_file_name();
		SLOG_INFO("receive <RequestSize:file=%s>", file_name.c_str());

		//大家一定要原谅我下面偷懒的行为
		string path="/data/"; 
		path += file_name;

		//get file size
		unsigned long long file_size=0;
		FILE *fp = fopen(path.c_str(), "r");
		if(fp != NULL)
		{
			fseek(fp, 0, SEEK_END);
			file_size = ftell(fp);
			fseek(fp, 0, SEEK_SET);
			fclose(fp);
		}
		DownloadProtocolFamily* protocol_family = (DownloadProtocolFamily*)get_protocol_family();
		RespondSize* resp_protocol = (RespondSize*)protocol_family->create_protocol(PROTOCOL_RESPOND_SIZE);
		if(resp_protocol)
		{
			resp_protocol->assign(file_name, file_size);
			send_protocol(socket_handle, resp_protocol);//发送回复
		}
		else
			SLOG_ERROR("create RespondSize protocol failed.");

		break;
	}
	case PROTOCOL_REQUEST_DATA: //请求数据
	{
		RequestData *temp_protocol = (RequestData*)protocol;
		const string file_name = temp_protocol->get_file_name();
		unsigned long long start_pos = temp_protocol->get_start_pos();
		unsigned int size = temp_protocol->get_size();
		SLOG_INFO("receive <RequestData: file=%s, start_pos=%ld, size=%d>", file_name.c_str(), start_pos, size);

		//大家一定要原谅我下面偷懒的行为
		string path="/data/";
		path += file_name;
		FILE *fp = fopen(path.c_str(), "r");
		if(fp != NULL)
		{
			IOBuffer io_buffer;
			fseek(fp, start_pos, SEEK_SET);
			char* buf = io_buffer.write_open(size);
			fread(buf, 1, size, fp);
			fclose(fp);
			string data;
			data.assign(buf, size);  //获取数据
			io_buffer.write_close(size);

			DownloadProtocolFamily* protocol_family = (DownloadProtocolFamily*)get_protocol_family();
			RespondData* resp_protocol = (RespondData*)protocol_family->create_protocol(PROTOCOL_RESPOND_DATA);
			if(resp_protocol)
			{
				resp_protocol->assign(file_name, start_pos, size);
				resp_protocol->assign(data);
				send_protocol(socket_handle, resp_protocol); //发送回复
			}
		}
		else
		{
			SLOG_ERROR("can't open file=%s", file_name.c_str());
		}
		break;
	}
	default:
		SLOG_WARN("receive undefine protocol. ignore it.");
		break;
	}

	return 0;
}
}}}


嗯,我们到下载服务器完成了.收工,洗洗睡了...
哦,忘记还有客户端的代码,顺便提供一下,嘿嘿...


= 3 Download Client =
实际上客户端的东西跟下载服务器没有太大的关系了,但是你总得对服务进行测试吧,人不能太懒了.更重要的是你不能说你利用框架搭了一个下载服务器,就说明它是OK的吧.(嗯,好,我们大家一起来验证一下...代码如下...我发现,客户端反而复杂了一点..)

客户端所做的事情如下:
 * 接收一个任务,请求该任务的文件大小
 * 将文件划分成若干数据块(分片任务),将每个分片分配到下载线程池下载
 * 下载完所有分片后合并成一个完整的文件 (请再次原谅我没有做这一步)


 * *1. 任务管理器TaskManager*
任务管理器其实是一个线程,用来接收任务,向服务器请求文件大小,然后将文件划分成分片任务提交给下载线程池,由下载线程池完成分片的下载任务.

任务管理器还从Netnterface派生,实现协议的发送和接收.

{{{
class TaskManager: public PipeThread<string>, public NetInterface
{
protected:
	//实现接口:线程实际运行的入口
	void run()
	{
		SLOG_INFO("ConnectThread[ID=%d] is running...", get_id());
		get_io_demuxer()->run_loop();
		SLOG_INFO("ConnectThread end...");
	}

	//实现接口:响应添加任务事件
	bool on_notify_add_task();
public:
	//////////////////由应用层重写 接收协议函数//////////////////
	int on_recv_protocol(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 协议发送错误处理函数//////////
	int on_protocol_send_error(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 协议发送成功处理函数//////////
	int on_protocol_send_succ(SocketHandle socket_handle, Protocol *protocol);
	//////////////////由应用层重写 连接错误处理函数//////////////
	int on_socket_handle_error(SocketHandle socket_handle);
	//////////////////由应用层重写 连接超时处理函数//////////////
	int on_socket_handle_timeout(SocketHandle socket_handle);

////////////////////////////////////////////////
public:
	TaskManager(IODemuxer *io_demuxer, ProtocolFamily *protocol_family, SocketManager *socket_manager)
			:PipeThread<string>(io_demuxer)
			 ,NetInterface(io_demuxer, protocol_family, socket_manager)
	{
		m_download_pool = NULL;
	}

	void set_download_pool(DownloadThreadPool* download_pool)
	{
		m_download_pool = download_pool;
	}
protected:
	bool send_get_filesize_task(string &file_name);
	bool download_task(const string &file_name, unsigned long long file_size);
private:
	DownloadThreadPool *m_download_pool;  //下载线程池

};
}}}

 * 接收任务
当外界调用thread的add_task()时,线程会收到添加任务的事件通知,然后调用on_notify_add_task响应该事件.在该函数里面我们调用send_get_filesize_task向下载服务器发送RequestSize协议请求文件大小.

{{{
bool TaskManager::on_notify_add_task()
{
	SLOG_DEBUG("Thread[ID=%d,Addr=%x] do task",get_id(), this);
	string file_name;
	while(get_task(file_name))
	{
		SLOG_DEBUG("Thread[ID=%d, Addr=%x] receive task=%s", get_id(), this, file_name.c_str());
		if(send_get_filesize_task(file_name) == false)
			SLOG_ERROR("sent get_file_size protocol failed. file_name=%s", file_name.c_str());
	}

	return true;
}
}}}

 * 接收RespondSize协议
当服务器回复文件大小时,由on_recv_protocol来响应,然后启动下载任务.
{{{
int TaskManager::on_recv_protocol(SocketHandle socket_handle, Protocol *protocol)
{
	switch(((DefaultProtocol*)protocol)->get_type())
	{
	case PROTOCOL_RESPOND_SIZE:
	{
		RespondSize *temp_protocol = (RespondSize*)protocol;
		const string file_name = temp_protocol->get_file_name();
		unsigned long long file_size = temp_protocol->get_file_size();
		SLOG_INFO("receive <RespondSize:file=%s, size=%ld>", file_name.c_str(), file_size);

		//下载文件
		if(file_size > 0)
			download_task(file_name, file_size);
		break;
	}
...省略若干文字...
}
}}}

 * 下载任务download_task
主要完成任务的分片,添加到下载线程池.在这里,为了偷工减料,我们设置每个分片大小为1M =) :p
{{{
bool TaskManager::download_task(const string &file_name, unsigned long long file_size)
{
	int i;
	unsigned long long start_pos = 0;
	unsigned long long split_size = 1024*1024;

	for(i=0; start_pos+split_size<=file_size; ++i,start_pos+=split_size)
	{
		DownloadTask *task = new DownloadTask;
		task->file_name = file_name;
		task->start_pos = start_pos;
		task->size = split_size;
		task->task_index = i;
		task->fp = NULL;
		task->down_size = 0;
		m_download_pool->add_task(task);
	}

	if(start_pos < file_size) //最后一个分片
	{
		DownloadTask *task = new DownloadTask;
		task->file_name = file_name;
		task->start_pos = start_pos;
		task->size = file_size-start_pos;
		task->task_index = i;
		task->fp = NULL;
		task->down_size = 0;
		m_download_pool->add_task(task);
	}
	return true;
}
}}}


 * *2. 下载线程*
下载线程池的内容我们就不说了,利用框架很快就可以搞一个出来.我们直接讲下载线程.

下载线程要做的事情主要有:
 (1) 接收TaskManager发送过来的下载任务
 (2) 从队列里面获取一个任务进行下载.
 (3) 下载完后跳到step 2. (即每个线程一次只下载一个分片任务)

 * 接收任务
同样,下载线程收到任务时,会收到on_notify_add_task的通知(怎么收呢?呃,框架帮你做了),在这里面我们发送一个下载任务,即发送一个RequestData请求.
{{{
bool DownloadThread::on_notify_add_task()
{
	SLOG_DEBUG("Thread[ID=%d,Addr=%x] do task",get_id(), this);
	return send_download_task();
}

bool DownloadThread::send_download_task(SocketHandle socket_handle)
{
	if(m_is_downloading)  //一次只执行一个下载任务
		return false;

	DownloadTask* download_task = NULL;
	if(get_task(download_task) && send_download_task(socket_handle, download_task))
		m_is_downloading = true;
	return true;
}
}}}

 * 接收数据
同样,还是在on_recv_protocol里面处理啦,都不用说的啦...
在接收完数据后, 会调用send_download_task来发送下一个分片任务的请求.

{{{
int DownloadThread::on_recv_protocol(SocketHandle socket_handle, Protocol *protocol)
{
	switch(((DefaultProtocol*)protocol)->get_type())
	{
	case PROTOCOL_RESPOND_DATA: //接收数据
	{
		RespondData* temp_protocol = (RespondData*)protocol;
		const string file_name = temp_protocol->get_file_name();
		unsigned long long start_pos = temp_protocol->get_start_pos();
		unsigned int size = temp_protocol->get_size();
		string data = temp_protocol->get_data();

		ostringstream temp;
		temp<<file_name<<"_"<<start_pos;
		DownloadMap::iterator it = m_downloading_task.find(temp.str());
		if(it == m_downloading_task.end())
		{
			SLOG_WARN("receive RespondData[file=%s, start=%ld], but can't not find task", file_name.c_str(), start_pos);
		}
		else
		{
			DownloadTask* task = it->second;
			SLOG_INFO("receive RespondData[fd=%d, file=%s, index=%d, start_pos=%ld, size=%d]", socket_handle, file_name.c_str(), task->task_index, start_pos, size);
			if(task->fp == NULL)
			{
				char buf[128];
				sprintf(buf, "%s.%d", task->file_name.c_str(), task->task_index);
				task->fp = fopen(buf, "wb");
			}

			fwrite(data.c_str(), 1, data.size(), task->fp);
			task->down_size += data.size();
			if(task->down_size == task->size)
			{
				SLOG_INFO("finish download[fd=%d, file=%s, index=%d]", socket_handle, file_name.c_str(), task->task_index);
				fclose(task->fp);
				delete task;
				m_downloading_task.erase(it);
				m_is_downloading = false;
				send_download_task(socket_handle); //请求下个任务
			}
		}
		break;
	}
	default:
		SLOG_WARN("receive undefine protocol. ignore it.");
		break;
	}

	return 0;
}
}}}

= 结束语 =
本节快速地介绍了用EasyNetwork框架快速地搭建一个下载服务器和下载客户端...感觉还不错吧.
贴几行log展示一下下载的过程吧:
